\documentclass{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{hyperref}


\begin{document}
\centerline{\LARGE{\bf{CSE206A Project: Fully Homomorphic Encryption}}}
\vspace{12.0pt}
\centerline{Michael Walter \hspace{0.1in} James Mouradian \hspace{0.1in} Victor Balcer}
\vspace{4.0pt}
\centerline{\today}

For our project we implemented fully homomorphic encryption, using the scheme
described in class and in lecture notes, using the Sage open-source mathematics
framework.

\section{Results}

We implemented a proof-of-concept NAND gate, since it is functionally complete.
The implementation is highly inefficient and features no alebraic
optimizations; our proof-of-concept takes approximately twenty minutes to
compute an encrypted NAND over two bits with the following parameters: $n=4$,
$q=64$, $Q=2^{25}$, and $\Beta=1$ (i.e. keys $s\in \mathbb{Z}_{64}^4$ and
$z\in\mathbb{Z}_{2^{25}}^4$). These are the smallest parameters for which we
can compute a NAND gate with error $\Beta > 0$. To validate the gate, we
computed an encrypted NAND over two randomly generated bits and compared the
the decrypted output with the expected output. Decryption was successful across
twenty independent trials. The the trials are meaningful; with increased error
the test reports both positive and negative results.

\section{Parameter Tuning}

% add smallest found parameters for beta=1 and n=8 with decryption and key switching
% add estimation of time for caculating nand operation on nand gates.

\begin{tabular}{r   l}
\textbf{Operation} & \textbf{Time} \\
\hline
decomposition & 39.8ms \\
matrix multiplication & 7.8ms \\
\end{tabular}


\section{Limitations and Optimizations}

For very small parameters, the limiting factor of our code is matrix binary
decomposition. After trying several optimizations within Sage, we migrated
this to low-level compiled code called from within Sage; however, the type 
conversions to and from Sage matrices took longer than performing the 
decomposition in Sage itself. Ultimately, we used a compiled version of the 
decomposition code, with pre-allocated space for each matrix. Additionally,
we pre-computed all constant decomposition matrices of unit vectors used in
convolution for homomorphic decrpytion.

As parameters increase even slightly, matrix multiplication approaches the 
decomposition function with respect to running time. With realistic parameters
that add any remote degree of security to homomorphic operations, matrix 
multiplication will clearly dominate the running time of our implementation.

\section{Future Work}

There are two obvious improvements to be made on this implementation. The first
is to use algebraic lattices, whose structure can be leveraged in order to
decrease the complexity of our implementation. The second is to focus on
implementation, using lower-level languages with hand-optimizations. Without
both of these in conjunction, the implementation will likely not ever become
fast enough to use for useful circuits in practice. 

\end{document}
